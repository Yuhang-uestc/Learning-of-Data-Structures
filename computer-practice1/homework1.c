#include <stdio.h>
#include <stdlib.h> 

// 定义顺序表结构体
#define MAX_SIZE 100  // 顺序表最大容量（可根据需求调整）
typedef struct {
    int data[MAX_SIZE];  // 存储顺序表的元素
    int length;          // 顺序表当前的元素个数（初始为0）
} SeqList;  // 给结构体起别名SeqList，后续使用更简洁

// 函数功能：创建顺序表（从键盘读入元素）
// 参数：SL :指向SeqList的指针（要操作的顺序表）
void CreateSeqList(SeqList *SL) 
{
    int n, i;  // n：用户输入的元素个数；i：循环变量
    
    // 初始化顺序表（长度先置0）
    SL->length = 0;
    // 读取输入的元素个数
    printf("请输入顺序表的元素个数：");
    scanf("%d", &n);
    
    // 逐个读取元素，存入顺序表
    printf("请输入%d个整数（空格分隔): ", n);
    
    for (i = 0; i < n; i++) 
	{
        scanf("%d", &(SL->data[i]));  // 将输入值存入data数组
        SL->length++;  // 每存一个元素，长度+1
    }
    
    // 输出顺序表
    printf("创建的顺序表元素：");
    for (i = 0; i < SL->length; i++)
	{
        printf("%d ", SL->data[i]);
    }
    printf("\n");
}

// 函数功能：在顺序表指定位置插入元素
// 参数：SL :指向SeqList的指针；pos :插入位置（1-based，符合用户习惯）；value :要插入的元素值
// 返回值：int - 1表示插入成功，0表示失败（位置非法/表满）
int InsertSeqList(SeqList *SL, int pos1, int value) 
{
    int i;
    
    // 判断插入位置是否在1~length+1之间，且表未满
    if (pos1 < 1 || pos1 > SL->length + 1)
	{
        printf("插入位置不合理！\n");
        return 0;
    }
    if (SL->length >= MAX_SIZE) 
	{
        printf("顺序表已满，无法插入！\n");
        return 0;
    }
    
    // 元素后移（从最后一个元素开始，到pos位置的前一个元素）
    for (i = SL->length; i >= pos1; i--) {
        SL->data[i] = SL->data[i - 1];  // 后移1位
    }
    
    // 插入新元素
    SL->data[pos1 - 1] = value;
    SL->length++;  // 长度+1
    
    // 输出插入后的顺序表
    printf("插入后的顺序表元素：");
    for (i = 0; i < SL->length; i++) 
	{
        printf("%d ", SL->data[i]);
    }
    printf("\n");
    return 1;
}

// 函数功能：删除顺序表指定位置的元素
// 参数：SL :指向SeqList的指针；pos :删除位置（1-based）
int DeleteSeqList(SeqList *SL, int pos2) 
{
    int i;
    
    // 判断删除位置是否在1~length之间
    if (pos2 < 1 || pos2 > SL->length) 
	{
        printf("删除位置不合理！\n");
        return 0;
    }
    
    // 元素前移（从pos位置开始，到最后一个元素的前一个）
    for (i = pos2; i < SL->length; i++) 
	{
        SL->data[i - 1] = SL->data[i];  // 前移1位
    }
    
    SL->length--;       // 长度-1
    
    // 输出删除后的顺序表
    printf("删除后的顺序表元素：");
    for (i = 0; i < SL->length; i++) 
	{
        printf("%d ", SL->data[i]);
    }
    printf("\n");
    return 1;
}

// 函数功能：统计顺序表中负数个数，并删除所有负数
// 参数：SL - 指向SeqList的指针
void CountAndDeleteNegative(SeqList *SL) 
{
    int i,j,count = 0;  // 负数个数变量
    
    // 遍历顺序表
    for (i=0; i < SL->length; ) 
	{
        if (SL->data[i] < 0)
		{ 
            count++;  // 遇到负数，计数+1
            for (j = i + 1; j < SL->length; j++) 
				{
			        SL->data[j - 1] = SL->data[j];  // 前移1位
			    }
            SL->length--; 
		}
		else
			i++;
    }
    // 输出结果
    printf("顺序表中负数的个数：%d\n", count);
    printf("删除负数后的顺序表元素：");
    for (i = 0; i < SL->length; i++) 
        printf("%d ", SL->data[i]);
    printf("\n");
}

// 函数功能：合并两个递增有序的顺序表A、B，生成递增有序的顺序表C
// 参数：A、B - 源顺序表（递增有序）；C - 目标顺序表（存储合并结果）
// 返回值：无（直接修改C）
void MergeSortedSeqList(SeqList A, SeqList B, SeqList *C) {
    int i = 0, j = 0, k = 0;  // i：A的索引；j：B的索引；k：C的索引
    
    while (i < A.length && j < B.length) 
	{
        if (A.data[i] <= B.data[j]) 
            C->data[k++] = A.data[i++];
		else
            C->data[k++] = B.data[j++];
    }
    
    // 处理A中剩余的元素
    while (i < A.length) 
	{
        C->data[k++] = A.data[i++];
    }
    // 处理B中剩余的元素
    while (j < B.length) {
        C->data[k++] = B.data[j++];
    }
    // 更新C的长度
    C->length = k;
    
    // 5. 输出合并后的顺序表
    printf("合并后的有序顺序表C：");
    for (int m = 0; m < C->length; m++) 
    {
        printf("%d ", C->data[m]);
    }
    printf("\n");
}

// 函数功能：求有序顺序表的中位数
// 参数：SL - 有序顺序表（递增/递减均可）
// 返回值：double - 中位数（若长度为偶数，返回中间两个数的平均值）
double GetMedian(SeqList SL) 
{
    if (SL.length == 0) 
	{
        printf("顺序表为空，无中位数！\n");
        return -1;  // 非法值标记
    }
    // 中位数计算逻辑：
    // - 长度为奇数：中间位置的元素（索引=length/2，整数除法）
    // - 长度为偶数：中间两个元素的平均值（索引=(length-1)/2 和 length/2）
    if (SL.length % 2 == 1) 
	{
        return SL.data[SL.length / 2];  // 奇数：直接返回中间元素
    } 
	else 
	{
        int mid1 = SL.data[(SL.length - 1) / 2];
        int mid2 = SL.data[SL.length / 2];
        return (mid1 + mid2) / 2.0;  // 偶数：返回平均值（用2.0确保浮点数）
    }
}

// 功能：判断顺序表SL是否为升序（非递减）
// 参数：SL - 指向要判断的顺序表的指针
// 返回值：1（升序）、0（非升序）、-1（空表，特殊处理）
int IsAscending(SeqList *SL) 
{
    // 边界情况1：空表或只有1个元素，默认是升序
    if (SL->length <= 1)
        return 1;
    // 遍历相邻元素，检查是否满足“前 <= 后”（非递减，符合实验中“递增有序”的常见定义）
    for (int i = 0; i < SL->length - 1; i++) 
	{
        // 若存在前元素 > 后元素，直接返回非升序
        if (SL->data[i] > SL->data[i + 1]) 
            return 0;
    }
    // 遍历结束无异常，返回升序
    return 1;
}

// 功能：对顺序表SL进行排序（升序）
void SortSeqList(SeqList *SL) 
{
    int i, j, temp;
    // 插入排序：从第2个元素开始（i=1），向前插入到合适位置
    for (i = 1; i < SL->length; i++)
   {
        temp = SL->data[i]; // 待插入元素
        j = i - 1;
        // 向前找比temp大的元素，依次后移
        while (j >= 0 && SL->data[j] > temp) {
            SL->data[j + 1] = SL->data[j];
            j--;
        }
        // 插入temp到正确位置
        SL->data[j + 1] = temp;
    }
}

// 函数功能：删除升序顺序表中的重复元素（每个元素只保留一次）
// 参数：SL - 指向升序顺序表的指针
void RemoveDuplicates(SeqList *SL) 
{
    int i, j = 0;  // j：记录不重复元素的位置（新顺序表的索引）
    
    if (SL->length <= 1) 
	{
        printf("顺序表元素个数≤1，无重复元素！\n");
        return;
    }

    // 去重（利用升序特性：重复元素必相邻）
    for (i = 1; i < SL->length; i++) 
	{
        // 若当前元素与前一个不重复（j位置的元素），则存入j+1位置
        if (SL->data[i] != SL->data[j]) 
		{
            j++;
            SL->data[j] = SL->data[i];
        }
    }
    
    // 更新顺序表长度（不重复元素的个数=j+1）
    SL->length = j + 1;
    
    // 输出去重后的顺序表
    printf("删除重复元素后的顺序表：");
    for (i = 0; i < SL->length; i++) 
	{
        printf("%d ", SL->data[i]);
    }
    printf("\n");
}


int main() 
{
    SeqList SL, A, B, C;  // SL：用于题目1-4、6；A、B、C：用于题目5
    int pos1,pos2,value;        // 存储插入/删除的位置和插入值
    
    // -------------------------- 题目1：创建顺序表 --------------------------
    printf("=== 题目1：创建顺序表 ===\n");
    CreateSeqList(&SL);
    printf("\n");
    
    // -------------------------- 题目2：插入元素 --------------------------
    printf("=== 题目2：插入元素 ===\n");
    printf("请输入要插入的元素值和位置（用空格分隔）：");
    scanf("%d %d", &value, &pos1);
    InsertSeqList(&SL, pos1, value);
    printf("\n");
    
    // -------------------------- 题目3：删除元素 --------------------------
    printf("=== 题目3：删除元素 ===\n");
    printf("请输入要删除的元素位置：");
    scanf("%d", &pos2);
    DeleteSeqList(&SL, pos2);
    printf("\n");
    
    // -------------------------- 题目4：统计并删除负数 --------------------------
    printf("=== 题目4：统计并删除负数 ===\n");
    CountAndDeleteNegative(&SL);
    printf("\n");
    
    // -------------------------- 题目5：合并有序表+求中位数 --------------------------
    printf("=== 题目5：合并两个递增有序表+求中位数 ===\n");
    // 先创建两个递增有序的顺序表A和B（示例：A=[1,3,5], B=[2,4,6]）
    printf("创建递增有序表A：\n");
    CreateSeqList(&A);
    printf("创建递增有序表B：\n");
    CreateSeqList(&B);
    // 合并A和B到C
    MergeSortedSeqList(A, B, &C);
    // 求C的中位数
    double M = GetMedian(C);
    printf("合并后顺序表C的中位数：%.1f\n", M);
    printf("\n");
    
    // -------------------------- 题目6：删除重复元素 --------------------------
    printf("=== 题目6：删除升序表中的重复元素 ===\n");
        // 先判断当前SL是否为升序
    if (IsAscending(&SL)) 
	{
        printf("当前顺序表为升序，直接执行去重操作\n");
    } 
    else
	{
        SortSeqList(&SL);
    }
    // 确认升序后，执行去重并输出 
    RemoveDuplicates(&SL);
    
    return 0;
}

